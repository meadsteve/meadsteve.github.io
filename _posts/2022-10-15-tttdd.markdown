---
layout: post
published: false
title:  "TTTDD - Types then Test Driven Development"
date:   2022-10-13 10:00:00
categories: programming
summary: "Notes on using TDD with a nestjs graphql backend"
icon: fab fa-js
tags:
    - tdd
    - typescript
    - graphql
---
I wanted to have an experiment using tdd with [nestjs](https://nestjs.com/) and [graphql](https://graphql.org/). I've
worked with graphql a little before and nestjs not at all. This post won't really have a conclusion, sales pitch
or any analysis but I wanted to document an approach that worked for me. I'm nicknaming it types then test driven 
development.

## The setup
I decide for the experiment I would create a small api which stores and queries blogposts via graphql.
There's a github repo [meadsteve/blogpost-tttdd-nestjs-graphql](https://github.com/meadsteve/blogpost-tttdd-nestjs-graphql)
with the full code for this experiment. I'll link to relevant commits along the way.

I started with nestjs default project template from `nest new --strict {path}` (see commit [69e25be](https://github.com/meadsteve/blogpost-tttdd-nestjs-graphql/commit/69e25be70d3fbc377f798867735a18ee843d0e46)).

I'm using [wallabyjs](https://wallabyjs.com/) as a test runner because I love getting rapid feedback in my IDE. It 
can work automatically with a jest based project but I added a little bit of configuration so that it found the end to
end tests created by nest as well as the inline spec files (commit [f357595](https://github.com/meadsteve/blogpost-tttdd-nestjs-graphql/commit/f357595badfa97edbc78b88e4d997ccba3047230)):

```javascript
// create wallaby.js

module.exports = function (wallaby) {
    return {
        autoDetect: true,

        files: ['src/**/*.ts', { pattern: 'src/**/*.spec.ts', ignore: true }],

        tests: ['src/**/*.spec.ts', 'test/**/*.e2e-spec.ts'],

        env: {
            type: 'node',
        },
    };
};
```

Wallaby now shows me `0 failing tests, 2 passing`, these are the two tests that come from the project template so
I now know everything is configured correctly.

## Adding graphql

Next I needed to setup graphql for the project so I installed the apollo server integration for nextjs

```bash
npm i @nestjs/graphql @nestjs/apollo graphql apollo-server-express
```

and modified `app.module.ts` to load it (commit [4c5e06e](https://github.com/meadsteve/blogpost-tttdd-nestjs-graphql/commit/4c5e06e095ecafb568b3a0417df6dc5fceef436c)):
```javascript
// src/app.module.ts
//...
imports: [
    GraphQLModule.forRoot<ApolloDriverConfig>({
        driver: ApolloDriver,
    }),
]
//...
```

but now wallaby tells me one of my tests is failing:

```
test/app.e2e-spec.ts AppController (e2e) / (GET) [41 ms]

	Error: Apollo Server requires either an existing schema, modules or typeDefs
```

The end to end test created by nest is failing because apollo expects something to do with graphql. 

## Dump

```

# nest g module blogposts

# code first
# Setup graphql (added to "src/app.module.ts")
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
      autoSchemaFile: join(process.cwd(), 'src/schema.gql'),
    }),


src/blogposts/models/blogpost.model.ts
@ObjectType()
export class BlogPost {
  @Field()
  title: string;

  @Field()
  content: string;
}

src/blogposts/blogposts.resolver.ts
@Resolver((of) => BlogPost)
export class BlogpostsResolver {
  @Query((returns) => [BlogPost])
  async blogposts(): Promise<BlogPost[]> {
    throw new NotImplementedException('CODE ME!');
  }
}

src/schema.gql

# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type BlogPost {
  title: String!
  content: String!
}

type Query {
  blogposts: [BlogPost!]!
}

# back to two passing tests
0 failing tests, 2 passing 

# But now we need a good test

query {
  blogposts{title, content}
}

{
  "errors": [
    {
      "message": "CODE ME!",
      "extensions": {
        "code": "501",
        "response": {
          "statusCode": 501,
          "message": "CODE ME!",
          "error": "Not Implemented"
        }
      }
    }
  ],
  "data": null
}

describe('Blog Posts (graphql e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('returns no posts when we dont have any', async () => {
    const query = `query{
      blogposts {title, content}
    }`;
    const { body } = await request(app.getHttpServer()).post('/graphql').send({
      query: query,
    });
    expect(body.data.blogposts).toEqual([]);
  });
});

# Passes - but it's still not useful
0 failing tests, 3 passing

# We need a mutation - back to types

  @Mutation((returns) => BlogPost, { name: 'blogpost' })
  async createBlogPost(
    @Args('title') title: string,
    @Args('content') content: string,
  ): Promise<BlogPost> {
    throw new NotImplementedException('CODE ME');
  }
  
mutation {
  blogpost(title: "First post", content: "weccome to my blog") {title, content}
}


# test for creation
  it('can post a blogpost and then see that its in the list', async () => {
    // Create the post
    const creationMutation = `mutation {
      blogpost(title: "First post", content: "welcome to my blog") {title, content}
    }`;
    await request(app.getHttpServer()).post('/graphql').send({
      query: creationMutation,
    });

    // Check that the post is found in the list
    const query = `query{
      blogposts {title, content}
    }`;
    const { body } = await request(app.getHttpServer()).post('/graphql').send({
      query: query,
    });
    expect(body.data.blogposts).toContainEqual({
      title: 'First post',
      content: 'welcome to my blog',
    });
  });
  
# Use regular TDD to create an in memory storage for blog posts
  providers: [
    BlogpostsResolver,
    {
      provide: 'BlogpostStorage',
      useClass: InMemoryBlogpostStorage,
    },
  ],
  
# Update the resolver to use this storage
@Resolver((of) => BlogPost)
export class BlogpostsResolver {
  constructor(@Inject('BlogpostStorage') private storage: BlogpostStorage) {}

  @Query((returns) => [BlogPost])
  async blogposts(): Promise<BlogPost[]> {
    return this.storage.getAllPosts();
  }

  @Mutation((returns) => BlogPost, { name: 'blogpost' })
  async createBlogPost(
    @Args('title') title: string,
    @Args('content') content: string,
  ): Promise<BlogPost> {
    const newPost = { title, content };
    this.storage.addNewPost(newPost);
    return newPost;
  }
}

```
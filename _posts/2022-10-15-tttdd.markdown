---
layout: post
published: false
title:  "TTTDD - Types then Test Driven Development"
date:   2022-10-13 10:00:00
categories: programming
summary: "Notes on using TDD with a nestjs graphql backend"
icon: fab fa-js
tags:
    - tdd
    - typescript
    - graphql
---

TODO: actually write

## Mention setup: wallaby, nest.js and graphql

## Steps: Graphql types first, then test, then implementation


## Dump

```
# new project
nest new --strict nestjs-tttdd 

# create wallaby.js

module.exports = function (wallaby) {
  return {
    autoDetect: true,

    files: ['src/**/*.ts', { pattern: 'src/**/*.spec.ts', ignore: true }],

    tests: ['src/**/*.spec.ts', 'test/**/*.e2e-spec.ts'],

    env: {
      type: 'node',
    },
  };
};

# 0 failing tests, 2 passing

# Graphql deps
npm i @nestjs/graphql @nestjs/apollo graphql apollo-server-express


# Setup graphql (added to "src/app.module.ts")
  imports: [
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
    }),
  ],

# !! an error

test/app.e2e-spec.ts AppController (e2e) / (GET) [41 ms]

	Error: Apollo Server requires either an existing schema, modules or typeDefs
	
# nest g module blogposts

# code first
# Setup graphql (added to "src/app.module.ts")
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
      autoSchemaFile: join(process.cwd(), 'src/schema.gql'),
    }),


src/blogposts/models/blogpost.model.ts
@ObjectType()
export class BlogPost {
  @Field()
  title: string;

  @Field()
  content: string;
}

src/blogposts/blogposts.resolver.ts
@Resolver((of) => BlogPost)
export class BlogpostsResolver {
  @Query((returns) => [BlogPost])
  async blogposts(): Promise<BlogPost[]> {
    throw new NotImplementedException('CODE ME!');
  }
}

src/schema.gql

# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type BlogPost {
  title: String!
  content: String!
}

type Query {
  blogposts: [BlogPost!]!
}

# back to two passing tests
0 failing tests, 2 passing 

# But now we need a good test

query {
  blogposts{title, content}
}

{
  "errors": [
    {
      "message": "CODE ME!",
      "extensions": {
        "code": "501",
        "response": {
          "statusCode": 501,
          "message": "CODE ME!",
          "error": "Not Implemented"
        }
      }
    }
  ],
  "data": null
}

describe('Blog Posts (graphql e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('returns no posts when we dont have any', async () => {
    const query = `query{
      blogposts {title, content}
    }`;
    const { body } = await request(app.getHttpServer()).post('/graphql').send({
      query: query,
    });
    expect(body.data.blogposts).toEqual([]);
  });
});

# Passes - but it's still not useful
0 failing tests, 3 passing

# We need a mutation - back to types

  @Mutation((returns) => BlogPost, { name: 'blogpost' })
  async createBlogPost(
    @Args('title') title: string,
    @Args('content') content: string,
  ): Promise<BlogPost> {
    throw new NotImplementedException('CODE ME');
  }
  
mutation {
  blogpost(title: "First post", content: "weccome to my blog") {title, content}
}


# test for creation
  it('can post a blogpost and then see that its in the list', async () => {
    // Create the post
    const creationMutation = `mutation {
      blogpost(title: "First post", content: "welcome to my blog") {title, content}
    }`;
    await request(app.getHttpServer()).post('/graphql').send({
      query: creationMutation,
    });

    // Check that the post is found in the list
    const query = `query{
      blogposts {title, content}
    }`;
    const { body } = await request(app.getHttpServer()).post('/graphql').send({
      query: query,
    });
    expect(body.data.blogposts).toContainEqual({
      title: 'First post',
      content: 'welcome to my blog',
    });
  });
  
# Use regular TDD to create an in memory storage for blog posts
  providers: [
    BlogpostsResolver,
    {
      provide: 'BlogpostStorage',
      useClass: InMemoryBlogpostStorage,
    },
  ],
  
# Update the resolver to use this storage
@Resolver((of) => BlogPost)
export class BlogpostsResolver {
  constructor(@Inject('BlogpostStorage') private storage: BlogpostStorage) {}

  @Query((returns) => [BlogPost])
  async blogposts(): Promise<BlogPost[]> {
    return this.storage.getAllPosts();
  }

  @Mutation((returns) => BlogPost, { name: 'blogpost' })
  async createBlogPost(
    @Args('title') title: string,
    @Args('content') content: string,
  ): Promise<BlogPost> {
    const newPost = { title, content };
    this.storage.addNewPost(newPost);
    return newPost;
  }
}

```